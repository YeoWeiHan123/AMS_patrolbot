###############
#DO NOT USE [ TAB ] FOR INDENTATION
###########
max_obstacle_height:         1.0        # assume something like an arm is mounted on top of the robot
# Obstacle Cost Shaping (http://wiki.ros.org/costmap_2d/hydro/inflation)
robot_radius:                0.150 

# distance a circular robot should be clear of the obstacle 
# footprint: [[x0, y0], [x1, y1], ... [xn, yn]]  # if the robot is not circular
footprint:                   [[-0.20, -0.15], [-0.30, 0.0], [-0.20, 0.15], [0.15, 0.15], [0.30, 0.0], [0.15, -0.15] ]
footprint_padding:           0.150
lethal_cost_threshold:       100

##Inflation layer is blue inflation, footprint padding is red inflation

#########################

obstacle_layer:
  enabled:                   true
  unknown_threshold:         1
  mark_threshold:            1
  combination_method:        1
  track_unknown_space:       true    #true needed for disabling global path planning through unknown space
  obstacle_range:            3.5
  raytrace_range:            4.0
  origin_z:                  0.0
  z_resolution:              0.4
  z_voxels:                  15
  publish_voxel_map:         false
  lethal_cost_threshold:     100
  observation_sources:       laser_top_scan_sensor laser_bottom_scan_sensor cloud


  laser_top_scan_sensor:
    sensor_frame:            laser
    data_type:               LaserScan
    topic:                   /scan_top
    marking:                 true
    clearing:                true
    inf_is_valid:            true    #true only for lasrscan
    min_obstacle_height:     0.0
    max_obstacle_height:     1.0
    expected_update_rate:    0.0     # default 0, if not updating at this rate at least, remove from buffer
    observation_persistence: 0.0     # default 0, use all measurements taken during now-value, 0=latest
    voxel_filter:            false   # default off, apply voxel filter to sensor, recommend on
    clear_after_reading:     false   # default false, clear the buffer after the layer gets readings from it

  laser_bottom_scan_sensor:
    sensor_frame:            laser
    data_type:               LaserScan
    topic:                   /scan_bottom
    marking:                 true
    clearing:                true
    inf_is_valid:            true    #true only for lasrscan
    min_obstacle_height:     0.0
    max_obstacle_height:     1.0
    expected_update_rate:    0.0     # default 0, if not updating at this rate at least, remove from buffer
    observation_persistence: 0.0     # default 0, use all measurements taken during now-value, 0=latest
    voxel_filter:            false   # default off, apply voxel filter to sensor, recommend on
    clear_after_reading:     false   # default false, clear the buffer after the layer gets readings from it

  cloud:
    data_type:               PointCloud2
    topic:                   /passthrough/output
    marking:                 true
    clearing:                true 
    inf_is_valid:            false
    min_obstacle_height:     0.0     # default 0, meters
    max_obstacle_height:     0.5     # default 3, meters
    expected_update_rate:    0.0     # default 0, if not updating at this rate at least, remove from buffer
    observation_persistence: 0.0     # default 0, use all measurements taken during now-value, 0=latest
    voxel_filter:            false    # default off, apply voxel filter to sensor, recommend on
    clear_after_reading:     false   # default false, clear the buffer after the layer gets readings from it

  sonar:
    data_type:               PointCloud
    topic:                   /RosAria/sonar
    marking:                 true
    clearing:                true 
    inf_is_valid:            false
    min_obstacle_height:     0.0    # default 0, meters
    max_obstacle_height:     1.0    # default 3, meters
    expected_update_rate:    0.0    # default 0, if not updating at this rate at least, remove from buffer
    observation_persistence: 0.0    # default 0, use all measurements taken during now-value, 0=latest
    voxel_filter:            false  # default off, apply voxel filter to sensor, recommend on
    clear_after_reading:     false  # default false, clear the buffer after the layer gets readings from it

#########################

#cost_scaling_factor and inflation_radius were now moved to the inflation_layer ns
inflation_layer:
  enabled:                  true
  cost_scaling_factor:      0.700 # exponential rate at which the obstacle cost drops off (default: 10) 0.58
  inflation_radius:         5.00  # max. distance from an obstacle at which costs are incurred for planning paths.
  lethal_cost_threshold:       100

#########################

static_layer:
  map_topic:                /map
  enabled:                  true
  lethal_cost_threshold:    100
  subscribe_to_updates:     false

#########################
#     NOT WORKING      ##
voxel_layer:
  enabled:                   true
  obstacle_range:            3.5
  raytrace_range:            4.0
  origin_z:                  0.0
  z_resolution:              0.4
  z_voxels:                  15
  unknown_threshold:         0
  mark_threshold:            0
  track_unknown_space:       true
  publish_voxel_map:         true
  combination_method:        1
  observation_sources:       cloud_

  cloud_:
    data_type:               PointCloud2
    topic:                   /passthrough/output
    marking:                 true
    clearing:                true 
    inf_is_valid:            false
    min_obstacle_height:     0.0     # default 0, meters
    max_obstacle_height:     1.0     # default 3, meters
    expected_update_rate:    0.0     # default 0, if not updating at this rate at least, remove from buffer
    observation_persistence: 0.0     # default 0, use all measurements taken during now-value, 0=latest
    voxel_filter:            true    # default off, apply voxel filter to sensor, recommend on
    clear_after_reading:     false   # default false, clear the buffer after the layer gets readings from it

voxel:
    observation_sources:     cloud_obstacles
    cloud_obstacles:         {sensor_frame: camera_depth_frame, data_type: PointCloud2, topic: /passthrough/output, marking: true, clearing: true}
#     NOT WORKING      ##
#########################

##       TO  DO        ##
##https://github.com/rst-tu-dortmund/costmap_prohibition_layer/tree/kinetic-devel/src##

#########################

#people_map:
#  observation_sources: tracked_persons
#  tracked_persons: {data_type: people_msgs/People, sensor_frame: laser, topic: /people }

people_map:
    observation_sources: tracked_persons
    tracked_persons: {data_type: TrackedPersons, sensor_frame: /base_link, topic: /people}


#prohibition_areas:
 # your first prohibited area is only a point
# - [17.09, -6.388]
 # now we define a line
 # it will become the thickness of the costmap resolution
# - [[8.33, 2.11],
#    [8.26, 5.11]]
 # and last but not least a polygon with an individual number of points
# - [[-11.15, -15.614],
#    [-12.35, -13.89],
#    [-10.05, -12.218]]
